<?php
/*Задание №1.
 Какие типы паттернов проектирования существуют?

Порождающие паттерны.
    Фабричный метод
    Абстрактная фабрика
    Строитель
    Синглтон
    Прототип

Структурные паттерны.
    Адаптер
    Компоновщик
    Декоратор
    Фасад

Поведенческие паттерны.
    Стратегия
    Шаблонный метод
    Наблюдатель
    Команда


Задание №2.
Как можно улучшить Singleton при помощи trait-ов?*/

trait SingletonTrait
{
	private static $instance;

	private function __construct()
	{
	}

	private function __clone()
	{
	}

	private function __wakeup()
	{
	}

	public static function getInstance() {
		if(empty(self::$instance)){
			self::$instance = new self();
		}
		return self::$instance;
    }
    
}

Class Test {
    use SingletonTrait;
    public $text = 'test';
}


$test1 = Test::getInstance();
echo $test1->text;

$test1->text = "<br/>Hello world";
echo $test1->text;

$test2 = Test::getInstance();
echo $test2->text;


/*
Задание №3.
Как реализуется паттерн «Фабричный метод»? В чем его отличие от паттерна «Фабрика»?

Фабричный метод предлагает создавать объекты не напрямую, используя оператор new, а через вызов особого фабричного метода. 

1. Создается абстрактный класс над классами, которые создают новые объекты (классы-создатели). 
(Абстрактный класс логистики, у которого есть абстрактный метод создать транспорт. Классы-создатели, наследует этот метод, 
при этом наземная логистика будет создать свой объект автомобиль через оператор new, а морская - корабль)

2. Создаются классы, которые реализуют общий интерфейс с каким-то методом (поведением, логикой), но каждый по-своему. 
(Классы  автомобиль, корабль реализуют интерфейс транспорт с методом доставить груз. Автомобиль - доставляет груз по суше, а корабль - по морю)

3. Для запуска реализуется функция, которая в качестве входного параметра принимает экземпляр нужного класса-создателя.


Фабрика обобщение всего, что относится к "Фабричный метод" и "Абстрактная фабрика"
Абстрактная фабрика уже включает несколько фабричных методов. Создание групп объектов со своими интерфейсами.
Классы-создатели создают несколько объектов и наследуются от абстрактной фабрики.


Задание №4.
Объясните назначение и применение магических методов __get, __set, __isset, __unset,
__call и __callStatic . Когда, как и почему их стоит использовать (или нет)?

Можно избавиться от геттеров и сеттеров если иcпользовать методы __get и __set.
__get метод срабатывает при попытке прочитать значение несуществующего или скрытого (то есть private или protected) свойства.
Если реализовать метод __get в каком-нибудь классе, то все обращения к несуществующим или скрытым свойствам будут обрабатываться этим методом.
__set метод вызывается при попытке изменить значение несуществующего или скрытого свойства.
но следует сделать проверку при обращении к несуществующим свойствам класса.

__isset() проверяет, установлено ли значение свойства  или нет. Данный метод принимает один аргумент - свойство, которое надо проверить.
Метод __isset() будет выполнен при использовании isset() или empty() на недоступных (защищенных или приватных) или несуществующих свойствах. 

Метод __unset() будет выполнен при вызове unset() на недоступном (защищенном или приватном) или несуществующем свойстве.
Метод __unset()принимает один аргумент, имя свойства, которое нужно сбросить.

__call() запускается при вызове недоступного (защищенном или приватном) или несуществующем методе в контексте объекта.
__callStatic() запускается при вызове недоступного (защищенном или приватном) или несуществующем методе в статическом контексте.
Аргумент $name представляет собой имя вызываемого метода. Аргумент $arguments представляет собой нумерованный массив, содержащий параметры, переданные в вызываемый метод $name.


Задание №5.
 Описать несколько структур данных из стандартной библиотеки PHP (SPL). Привести
примеры использования.
*/
// Инициализация массива фиксированной длиной
$array = new SplFixedArray(5);

$array[1] = 2;
$array[4] = "foo";
echo '<pre>';
var_dump($array[0]); // NULL
var_dump($array[1]); // int(2)

var_dump($array["4"]); // string(3) "foo"

// Увеличение размера массива до 10
$array->setSize(10);


$array[9] = "asdf";
var_dump($array);

var_dump($array->valid()); //Возвращает TRUE, если массив содержит хотя бы один элемент, и FALSE в противном случае.
var_dump($array->count()); // возвращает размер массива 10
var_dump($array->key()); // возвращает индекс текущего элемента массива  0
$array->next(); //Переходит к следующему элементу массива 1
var_dump($array->current()); // возвращает текущий элемент массива 2




/*
Задание №6.
Найти все ошибки в коде:

*/
